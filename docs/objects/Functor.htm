<html><head>
<title>Function Objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css">
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Function Objects</h1>
<h1>函数对象</h1>

<p>"Function object" usually means any of the following:</p>
<p>"函数对象"泛指以下内容：</p>
<ul>
  <li>A reference to a Func object, which represents an actual function; either built-in or defined by the script.</li>
  <li><a href="Func.htm">函数对象</a>, 即<a href="../Functions.htm">函数</a>的对象形式; 包含内置函数及脚本定义的函数</li>
  <li>A user-defined object which can be called like a function.  This is sometimes also referred to as a "functor".</li>
  <li>支持像函数一样被调用的用户定义的对象。亦称为“函数子”。</li>
  <li>Any other object which can be called like a function, such as a <a href="#BoundFunc">BoundFunc object</a> or a JavaScript function object returned by a COM method.</li>
  <li>其他支持像函数一样被调用的对象，如，<a href="#BoundFunc">扩展函数对象</a>，或，COM方法返回的JavaScript函数对象。</li>
</ul>
<p>Function objects can be used with the following:</p>
<p>函数对象可被以下对象使用：</p>
<ul>
  <li><a href="../commands/Gui.htm#label">Gui control events</a> (g-labels)
<a href="../commands/Gui.htm#label">GUI控件事件</a>（G标签）</li>
  <li><a href="../commands/Hotkey.htm#Functor">Hotkey</a><a href="../commands/Hotkey.htm#Functor">热键</a></li>
  <li><a href="../commands/Menu.htm#Functor">Menu</a>
<a href="../commands/Menu.htm#Functor">菜单</a></li>
  <li><a href="../commands/OnClipboardChange.htm">OnClipboardChange()</a></li>
  <li><a href="../commands/OnExit.htm">OnExit()</a></li>
  <li><a href="../commands/OnMessage.htm">OnMessage()</a></li>
  <li><a href="../commands/SetTimer.htm#Functor">SetTimer</a></li>
</ul>

<h2 id="User-Defined">User-Defined</h2><h2 id="User-Defined">用户定义函数</h2>
<!-- TODO: Explain how a user-defined object could be useful -->
<p>User-defined function objects should follow this general pattern:</p><p>用户定义函数对象应按以下模式：</p>
<pre>class YourClassName {
    Call(a, b) {  <em>; Declare parameters as needed, or an <a href="../Functions.htm#Variadic">array*</a>.
;声明参数，或<a href="../Functions.htm#Variadic">数组*</a>。</em>
        <em>;...</em>
    }
    __Call(method, args*) {
        if (method = "")  <em>; For <a href="../Functions.htm#DynCall">%fn%()</a> or fn.()</em>
            return this.Call(args*)
        if (IsObject(method))  <em>; If this function object is being used as a method.</em>
<em>; 如果此函数对象作为方法被使用。</em>
            return this.Call(method, args*)
    }
    <em>;...</em>
}
</pre>
<p>Exactly which parts are needed depends on the usage:</p><p>模式中各个部分适用于不同的使用情形，如下：</p>
<ul>
  <li><code>method</code> is an empty string if the script used <code><a href="../Functions.htm#DynCall">%this%()</a></code> or <code>this.()</code>.</li>
<li>如果脚本按<a href="../Functions.htm#DynCall">%this%()</a>或<code>this.()</code>的形式调用，则，<code>method</code>（方法名）的值是空字符串。</li>
  <li>If the object is being used as a method, <code>IsObject(method)</code> is true and <code>method</code> contains a reference to the target object. For example, if <code>x.y</code> refers to <code>this</code> function object, <code>x.y()</code> → <code>this[x]()</code> → <code>this.__Call(x)</code> → <code>this.Call(x)</code>.
<li>如果对象作为方法被调用，则<code>IsObject(method)</code>返回真，并且<code>method</code>包含关于目标对象的引用。如，如果<code>x.y</code>指向<code>this</code> 函数对象，则<code>x.y()</code> → <code>this[x]()</code> → <code>this.__Call(x)</code> → <code>this.Call(x)</code>.</li></li>
  <li><span class="ver">[v1.1.20+]:</span> If the object is being used by one of the built-in functions which accept a callback function, such as OnMessage or SetTimer, only the Call method is needed.</li><li><span class="ver">[v1.1.20+]:</span>如果对象被某需要回调函数的内置函数所使用，如OnMessage或SetTimer，则此对象仅需要支持Call方法即可。</li>
</ul>
<p>The work can also be done directly in __Call. However, having __Call redirect to Call is recommended to ease the transition to AutoHotkey v2, which will change the behaviour of <code>%this%()</code> and method calls to call the Call method directly.</p>
<p>上述过程可以直接在__Call中完成，推荐使用__Call代替Call以便更好的迁移到V2版本，其会改变<code>%this%()</code>的行为及调用CALL的方法调用。</p>

<h2 id="BoundFunc">BoundFunc Object <span class="ver">[v1.1.20+]</span></h2>
<p>Acts like a function, but just passes predefined parameters to another function.</p>
<p>There are two ways that BoundFunc objects can be created:</p>
<ul>
  <li>By calling the <a href="Func.htm#Bind">Func.Bind()</a> method, which binds parameter values to a function.</li>
  <li>By calling the <a href="../commands/ObjBindMethod.htm">ObjBindMethod()</a> function, which binds parameter values and a method name to a target object.</li>
</ul>
<p>BoundFunc objects can be called as shown in the example below. No other methods are supported. When the BoundFunc is called, it calls the function or method to which it is bound, passing any bound parameters followed by any which were passed by the caller. For example:</p>
<pre>fn := Func("RealFn").Bind(1)

%fn%(2)    <em>; Shows "1, 2"</em>
fn.Call(3) <em>; Shows "1, 3"</em>

RealFn(a, b) {
    MsgBox %a%, %b%
}</pre>
<p><a href="../commands/ObjBindMethod.htm">ObjBindMethod()</a> can be used to bind to a method when it isn't possible to retrieve a reference to the method itself.  For example:</p>
<pre>file := FileOpen(A_ScriptFullPath, "r")
getLine := ObjBindMethod(file, "ReadLine")
MsgBox % %getLine%()  <em>; Shows the first line of this file.</em></pre>



</body></html>